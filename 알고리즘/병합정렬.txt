merge(A, left, mid, right){
#left에서 mid까지 정렬, mid + 1에서 right까지 정렬되어 있는 상태
i = left;
j = mid + 1;
k = 0;

while(i <= mid && j <= right){
if(A[i] < A[j]){
C[k] = A[i]
i += 1;
}
else{
C[k] = A[j];
j+=1;
}
k += 1;
}
}

if(i < =mid){
for (int p = i; p <= mid; p++){
C[k] = A[p]
k +=1 ;}

else
for(int p = j; p <= right; p++){
C[k] = A[p]
k +=1;}

C를 A에 복사를 해야한다...
C(0~ k-1)을 A[left~ right]에 복사

단점은 C라는 배열을 추가 생성하므로, 추가적인 메모리가 필요하다.


추가적인 메모리가 상수인 알고리즘을 in - place 알고리즘이라고 한다.
병합정렬은 추가적으로 사용하는 메모리를 O(n)만큼 필요하다.
병합정렬은 in place 알고리즘이 아니다.

배열 개수 가 n개라고 하면 총 노드의 개수는
2n - 1이다.

이진트리에서 리프 노드(맨 끝단의 노드) 수가 n0라 하면
자식 노드가 2인 노드 수 n2
n2 = n0-1


중요!!!!!!!!!!!!!!!!!!!!!!!!
전체 호출 횟수는 2n -1이다.
팩토리얼은 또 다르다...
함수의 전체 호출 횟수를 구하시오...


비교연산은 merge할때 비교한다.
 똑같은 크기로 나눴으니 n/2<= merge의 비교횟수 <= m+n-1인데, 한배열이므로 n-1
t(n) = t(n/2) + cn이므로
O(nlogn)이다

입력의 상태와 관계없이 nlogn 시간이 걸린다.
샌드위치 정의... 인것 같다
